'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-f34d78e1.js');
const index$1 = require('./index-8af06bf3.js');
const focusHandling = require('./focusHandling-8850989b.js');

/**
 * Universal pagination model generation algorithm
 *
 * The idea behind this module is to move the logic of creating pagination out of the component
 * and place it in a separate module.
 *
 * Adapted from ultimate-pagination
 * https://github.com/ultimate-pagination/ultimate-pagination
 *
 */
const itemTypes = {
    PAGE: 'PAGE',
    ELLIPSIS: 'ELLIPSIS',
    PREVIOUS_PAGE_LINK: 'PREVIOUS_PAGE_LINK',
    NEXT_PAGE_LINK: 'NEXT_PAGE_LINK'
};
const itemKeys = {
    FIRST_ELLIPSIS: -1,
    SECOND_ELLIPSIS: -2,
    PREVIOUS_PAGE_LINK: -4,
    NEXT_PAGE_LINK: -5
};
const createFirstEllipsis = (pageNumber) => ({
    type: itemTypes.ELLIPSIS,
    key: itemKeys.FIRST_ELLIPSIS,
    value: pageNumber,
    isActive: false
});
const createSecondEllipsis = (pageNumber) => ({
    type: itemTypes.ELLIPSIS,
    key: itemKeys.SECOND_ELLIPSIS,
    value: pageNumber,
    isActive: false
});
const createPreviousPageLink = (options) => {
    const { activePage } = options;
    return {
        type: itemTypes.PREVIOUS_PAGE_LINK,
        key: itemKeys.PREVIOUS_PAGE_LINK,
        value: Math.max(1, activePage - 1),
        isActive: activePage > 1
    };
};
const createNextPageLink = (options) => {
    const { activePage, pageTotal } = options;
    return {
        type: itemTypes.NEXT_PAGE_LINK,
        key: itemKeys.NEXT_PAGE_LINK,
        value: Math.min(pageTotal, activePage + 1),
        isActive: activePage < pageTotal
    };
};
const createPageFunctionFactory = (options) => {
    const { activePage } = options;
    return (pageNumber) => ({
        type: itemTypes.PAGE,
        key: pageNumber,
        value: pageNumber,
        isActive: pageNumber === activePage
    });
};
const createRange = (start, end) => {
    const range = [];
    for (let i = start; i <= end; i++) {
        range.push(i);
    }
    return range;
};
const createPaginationModel = (options) => {
    // exception tests
    if (options == null) {
        throw new Error('createPaginationModel(): options object should be a passed');
    }
    const { pageTotal, activePage, pageRange } = options;
    const boundaryPagesRange = 1;
    const ellipsisSize = 1;
    const paginationModel = [];
    const createPage = createPageFunctionFactory(options);
    paginationModel.push(createPreviousPageLink(options));
    // Simplify generation of pages if number of available items is equal or greater than total pages to show
    if (1 + 2 * ellipsisSize + 2 * pageRange + 2 * boundaryPagesRange >= pageTotal) {
        const allPages = createRange(1, pageTotal).map(createPage);
        paginationModel.push(...allPages);
    }
    else {
        // Calculate group of first pages
        const firstPagesStart = 1;
        const firstPagesEnd = boundaryPagesRange;
        const firstPages = createRange(firstPagesStart, firstPagesEnd).map(createPage);
        // Calculate group of last pages
        const lastPagesStart = pageTotal + 1 - boundaryPagesRange;
        const lastPagesEnd = pageTotal;
        const lastPages = createRange(lastPagesStart, lastPagesEnd).map(createPage);
        // Calculate group of main pages
        const mainPagesStart = Math.min(Math.max(activePage - pageRange, firstPagesEnd + ellipsisSize + 1), lastPagesStart - ellipsisSize - 2 * pageRange - 1);
        const mainPagesEnd = mainPagesStart + 2 * pageRange;
        const mainPages = createRange(mainPagesStart, mainPagesEnd).map(createPage);
        // Add group of first pages
        paginationModel.push(...firstPages);
        // Calculate and add ellipsis before group of main pages
        const firstEllipsisPageNumber = mainPagesStart - 1;
        const showPageInsteadOfFirstEllipsis = firstEllipsisPageNumber === firstPagesEnd + 1;
        const createFirstEllipsisOrPage = showPageInsteadOfFirstEllipsis ? createPage : createFirstEllipsis;
        const firstEllipsis = createFirstEllipsisOrPage(firstEllipsisPageNumber);
        paginationModel.push(firstEllipsis);
        // Add group of main pages
        paginationModel.push(...mainPages);
        // Calculate and add ellipsis after group of main pages
        const secondEllipsisPageNumber = mainPagesEnd + 1;
        const showPageInsteadOfSecondEllipsis = secondEllipsisPageNumber === lastPagesStart - 1;
        const createSecondEllipsisOrPage = showPageInsteadOfSecondEllipsis ? createPage : createSecondEllipsis;
        const secondEllipsis = createSecondEllipsisOrPage(secondEllipsisPageNumber);
        paginationModel.push(secondEllipsis);
        // Add group of last pages
        paginationModel.push(...lastPages);
    }
    paginationModel.push(createNextPageLink(options));
    return paginationModel;
};
const getCurrentActivePage = (activePage, totalPages) => {
    // exception tests
    if (activePage === undefined || totalPages === undefined) {
        throw new Error('getCurrentActivePage(): activePage and totalPages props must be provided');
    }
    // Obviously we can't be on a negative or 0 page.
    if (activePage < 1) {
        activePage = 1;
    }
    // If the user has done something like /page/99999 we want to clamp that back down.
    if (activePage > totalPages) {
        activePage = totalPages;
    }
    return activePage;
};
const getTotalPages = (totalItemsCount, itemsPerPage) => {
    // exception test
    if (totalItemsCount === undefined || itemsPerPage === undefined) {
        throw new Error('getTotalPages(): totalItemsCount and itemsPerPage props must be provided');
    }
    if (totalItemsCount < 1) {
        totalItemsCount = 1;
    }
    if (itemsPerPage < 1) {
        itemsPerPage = 1;
    }
    return Math.ceil(totalItemsCount / itemsPerPage);
};

const listeners = new Map();
const handleResize = index$1.throttle(500, () => {
    listeners.forEach(callback => {
        callback();
    });
});
const attachListenerIfNeeded = () => {
    if (listeners.size === 1) {
        window.addEventListener('resize', handleResize);
    }
};
const removeListenerIfNotNeededAnymore = () => {
    if (listeners.size < 1) {
        window.removeEventListener('resize', handleResize);
    }
};
const listenResize = (callback) => {
    const token = {};
    listeners.set(token, callback);
    attachListenerIfNeeded();
    return () => {
        listeners.delete(token);
        removeListenerIfNotNeededAnymore();
    };
};

const readCounterResetValue = (element) => {
    const computedStyles = window.getComputedStyle(element);
    const resetValues = computedStyles.getPropertyValue('counter-reset');
    const resetValuesAsObject = resetValues.split(' ').reduce((accumulator, value) => {
        if (!accumulator.buffer) {
            return Object.assign(Object.assign({}, accumulator), { buffer: value });
        }
        return {
            buffer: null,
            result: Object.assign(Object.assign({}, accumulator.result), { [accumulator.buffer]: parseInt(value, 10) })
        };
    }, {
        buffer: null,
        result: {}
    });
    return resetValuesAsObject.result;
};

const paginationCss = "@charset \"UTF-8\";:host{display:block}.p-pagination{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;margin:0;padding:0}.p-pagination--size-5{counter-reset:size 5}.p-pagination--size-7{counter-reset:size 7}@media (min-width: 480px){.p-pagination--size-5-xs{counter-reset:size 5}.p-pagination--size-7-xs{counter-reset:size 7}}@media (min-width: 760px){.p-pagination--size-5-s{counter-reset:size 5}.p-pagination--size-7-s{counter-reset:size 7}}@media (min-width: 1000px){.p-pagination--size-5-m{counter-reset:size 5}.p-pagination--size-7-m{counter-reset:size 7}}@media (min-width: 1300px){.p-pagination--size-5-l{counter-reset:size 5}.p-pagination--size-7-l{counter-reset:size 7}}@media (min-width: 1760px){.p-pagination--size-5-xl{counter-reset:size 5}.p-pagination--size-7-xl{counter-reset:size 7}}.p-pagination__items{display:-ms-flexbox;display:flex;margin:0;padding:0}.p-pagination__item{list-style-type:none;margin:0;padding:0}.p-pagination__goto,.p-pagination__prev,.p-pagination__next{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;-webkit-transition:color 0.24s ease, outline-color 0.24s ease;transition:color 0.24s ease, outline-color 0.24s ease;position:relative;width:2.5rem;height:2.5rem;-webkit-box-sizing:border-box;box-sizing:border-box;outline:none transparent}.p-pagination__goto:focus,.p-pagination__prev:focus,.p-pagination__next:focus{outline-width:2px;outline-style:solid}.p-pagination--theme-light .p-pagination__goto:focus,.p-pagination--theme-light .p-pagination__prev:focus,.p-pagination--theme-light .p-pagination__next:focus{outline-color:#00d5b9}.p-pagination--theme-dark .p-pagination__goto:focus,.p-pagination--theme-dark .p-pagination__prev:focus,.p-pagination--theme-dark .p-pagination__next:focus{outline-color:#00d5b9}.p-pagination__goto:active,.p-pagination__prev:active,.p-pagination__next:active{outline:none}.p-pagination--theme-light .p-pagination__goto:active,.p-pagination--theme-light .p-pagination__prev:active,.p-pagination--theme-light .p-pagination__next:active{color:#d5001c}.p-pagination--theme-dark .p-pagination__goto:active,.p-pagination--theme-dark .p-pagination__prev:active,.p-pagination--theme-dark .p-pagination__next:active{color:#d5001c}.p-pagination__goto{font-size:1rem;line-height:1.5;font-family:\"Porsche Next\", \"Arial Narrow\", Arial, sans-serif;font-weight:400;text-decoration:none;cursor:pointer}.p-pagination--theme-light .p-pagination__goto{color:#000}.p-pagination--theme-dark .p-pagination__goto{color:#fff}.p-pagination--theme-light .p-pagination__goto:hover{color:#d5001c}.p-pagination--theme-dark .p-pagination__goto:hover{color:#d5001c}.p-pagination__goto--current{cursor:default}.p-pagination--theme-light .p-pagination__goto--current:hover{color:#000}.p-pagination--theme-dark .p-pagination__goto--current:hover{color:#fff}.p-pagination__goto--current::after{content:\"\";display:block;position:absolute;bottom:0;left:0.375rem;right:0.375rem;height:0.25rem}.p-pagination--theme-light .p-pagination__goto--current::after{background-color:#d5001c}.p-pagination--theme-dark .p-pagination__goto--current::after{background-color:#d5001c}.p-pagination__goto--ellipsis{cursor:default}.p-pagination--theme-light .p-pagination__goto--ellipsis:hover{color:#000}.p-pagination--theme-dark .p-pagination__goto--ellipsis:hover{color:#fff}.p-pagination__goto--ellipsis::after{content:\"…\"}.p-pagination__prev,.p-pagination__next{text-decoration:none;cursor:pointer}.p-pagination--theme-light .p-pagination__prev,.p-pagination--theme-light .p-pagination__next{color:#000}.p-pagination--theme-dark .p-pagination__prev,.p-pagination--theme-dark .p-pagination__next{color:#fff}.p-pagination--theme-light .p-pagination__prev:hover,.p-pagination--theme-light .p-pagination__next:hover{color:#d5001c}.p-pagination--theme-dark .p-pagination__prev:hover,.p-pagination--theme-dark .p-pagination__next:hover{color:#d5001c}.p-pagination__prev--disabled,.p-pagination__next--disabled{cursor:default}.p-pagination--theme-light .p-pagination__prev--disabled,.p-pagination--theme-light .p-pagination__next--disabled{color:#96989a}.p-pagination--theme-dark .p-pagination__prev--disabled,.p-pagination--theme-dark .p-pagination__next--disabled{color:#7c7f81}.p-pagination--theme-light .p-pagination__prev--disabled:hover,.p-pagination--theme-light .p-pagination__next--disabled:hover{color:#96989a}.p-pagination--theme-dark .p-pagination__prev--disabled:hover,.p-pagination--theme-dark .p-pagination__next--disabled:hover{color:#7c7f81}";

const Pagination = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        /** The total count of items. */
        this.totalItemsCount = 1;
        /** The total count of items which should be shown per page.  */
        this.itemsPerPage = 1;
        /** Index of the currently active page. */
        this.activePage = 1;
        /** The maximum number of page links rendered */
        this.maxNumberOfPageLinks = { base: 5, xs: 7 };
        /** Aria label what the pagination is used for. */
        this.allyLabel = 'Pagination';
        /** Aria label for previous page icon. */
        this.allyLabelPrev = 'Previous page';
        /** Aria label for page navigation. */
        this.allyLabelPage = 'Page';
        /** Aria label for next page icon. */
        this.allyLabelNext = 'Next page';
        /** Adapts the color when used on dark background. */
        this.theme = 'light';
        this.pageChange = index.createEvent(this, "pageChange", 7);
    }
    onActivePageChange(page, previousPage) {
        this.pageChange.emit({ page, previousPage });
    }
    componentDidLoad() {
        focusHandling.improveFocusHandlingForCustomElement(this.element);
        this.unlistenResize = listenResize(() => {
            this.updateMaxNumberOfPageLinks();
        });
        this.updateMaxNumberOfPageLinks();
    }
    componentDidUnload() {
        this.unlistenResize();
    }
    render() {
        const breakpointClasses = index$1.mapBreakpointPropToPrefixedClasses('pagination--size', this.maxNumberOfPageLinks);
        const pageRange = this.breakpointMaxNumberOfPageLinks === 7 ? 1 : 0;
        const paginationClasses = index$1.cx(breakpointClasses, index$1.prefix('pagination'), index$1.prefix(`pagination--theme-${this.theme}`));
        const paginationItemsClasses = index$1.cx(index$1.prefix('pagination__items'));
        const pageTotal = getTotalPages(this.totalItemsCount, this.itemsPerPage);
        const activePage = getCurrentActivePage(this.activePage, pageTotal);
        // generate pagination items
        const createPaginationItems = () => {
            const paginationModel = createPaginationModel({
                activePage,
                pageTotal,
                pageRange
            });
            const pageItems = [];
            let prevItem;
            let nextItem;
            const paginationItemClasses = index$1.cx(index$1.prefix('pagination__item'));
            paginationModel.forEach((pageModel) => {
                if (pageModel.type === itemTypes.PREVIOUS_PAGE_LINK) {
                    const paginationPrevClasses = index$1.cx(index$1.prefix('pagination__prev'), !pageModel.isActive && index$1.prefix('pagination__prev--disabled'));
                    return (prevItem = (index.h("li", Object.assign({}, pageModel, { class: paginationItemClasses }), index.h("span", { class: paginationPrevClasses, role: 'button', tabIndex: pageModel.isActive ? 0 : null, onClick: () => {
                            this.onClick(pageModel.value);
                        }, onKeyDown: (e) => {
                            this.onKeyDown(e, pageModel.value);
                        }, "aria-disabled": !pageModel.isActive && 'true', "aria-label": this.allyLabelPrev }, index.h("p-icon", { name: 'arrow-head-left', color: 'inherit' })))));
                }
                if (pageModel.type === itemTypes.ELLIPSIS) {
                    const paginationGoToClasses = index$1.cx(index$1.prefix('pagination__goto'), index$1.prefix('pagination__goto--ellipsis'));
                    pageItems.push(index.h("li", Object.assign({}, pageModel, { class: paginationItemClasses }), index.h("span", { class: paginationGoToClasses })));
                }
                if (pageModel.type === itemTypes.PAGE) {
                    const paginationGoToClasses = index$1.cx(index$1.prefix('pagination__goto'), pageModel.isActive && index$1.prefix('pagination__goto--current'));
                    pageItems.push(index.h("li", Object.assign({}, pageModel, { class: paginationItemClasses }), index.h("span", { class: paginationGoToClasses, role: 'button', tabIndex: pageModel.isActive ? null : 0, "aria-disabled": pageModel.isActive && 'true', onClick: () => {
                            this.onClick(pageModel.value);
                        }, onKeyDown: (e) => {
                            this.onKeyDown(e, pageModel.value);
                        }, "aria-label": `${this.allyLabelPage} ${pageModel.value}`, "aria-current": pageModel.isActive && 'page' }, pageModel.value)));
                }
                if (pageModel.type === itemTypes.NEXT_PAGE_LINK) {
                    const paginationNextClasses = index$1.cx(index$1.prefix('pagination__next'), !pageModel.isActive && index$1.prefix('pagination__next--disabled'));
                    return (nextItem = (index.h("li", Object.assign({}, pageModel, { class: paginationItemClasses }), index.h("span", { class: paginationNextClasses, role: 'button', tabIndex: pageModel.isActive ? 0 : null, onClick: () => {
                            this.onClick(pageModel.value);
                        }, onKeyDown: (e) => {
                            this.onKeyDown(e, pageModel.value);
                        }, "aria-disabled": !pageModel.isActive && 'true', "aria-label": this.allyLabelNext }, index.h("p-icon", { name: 'arrow-head-right', color: 'inherit' })))));
                }
            });
            return {
                prevItem,
                pageItems,
                nextItem
            };
        };
        const paginationItems = createPaginationItems();
        return (index.h("nav", { class: paginationClasses, role: 'navigation', "aria-label": this.allyLabel, ref: el => this.navigationElement = el }, index.h("ul", { class: paginationItemsClasses }, paginationItems.prevItem, paginationItems.pageItems, paginationItems.nextItem)));
    }
    onKeyDown(event, page) {
        /**
         * from https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/button_role
         */
        if (event.key === ' ' || event.key === 'Enter' || event.key === 'Spacebar') {
            /**
             * Prevent the default action to stop scrolling when space is pressed
             */
            event.preventDefault();
            this.onClick(page);
        }
    }
    onClick(page) {
        if (page !== this.activePage) {
            this.activePage = page;
        }
    }
    updateMaxNumberOfPageLinks() {
        const { size } = readCounterResetValue(this.navigationElement);
        this.breakpointMaxNumberOfPageLinks = size;
    }
    get element() { return index.getElement(this); }
    static get watchers() { return {
        "activePage": ["onActivePageChange"]
    }; }
};
Pagination.style = paginationCss;

exports.p_pagination = Pagination;
