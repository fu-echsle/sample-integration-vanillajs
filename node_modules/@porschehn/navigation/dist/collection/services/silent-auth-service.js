import { AuthorizationServiceConfiguration } from '@openid/appauth/built/authorization_service_configuration';
import { RedirectRequestHandler } from '@openid/appauth/built/redirect_based_handler';
import { BaseTokenRequestHandler } from '@openid/appauth/built/token_request_handler';
import { GRANT_TYPE_AUTHORIZATION_CODE, TokenRequest } from '@openid/appauth/built/token_request';
import { AuthorizationRequest } from '@openid/appauth/built/authorization_request';
import { NoHashQueryStringUtils } from './no-hash-query-string-utils';
import { LocalStorageBackend } from '@openid/appauth/built/storage';
import { FetchRequestor } from '@openid/appauth/built/xhr';
import { config } from '../env-config';
import * as Logger from './logger';
import { createHiddenIFrame } from './create-hidden-iframe';
import { ACCESS_TOKEN_FETCHED_EVENT, ACCESS_TOKEN_FETCH_ERROR_EVENT } from '../utility/constants';
export const fetchAccessToken = async (tokenReceivedHandler, errorHandler, env) => {
    let authorizationServiceConfiguration, tokenHandler, authorizationHandler;
    const iFrameAuth = createHiddenIFrame();
    const envConfig = config(env);
    const fetchRequestor = new FetchRequestor();
    try {
        authorizationServiceConfiguration = await AuthorizationServiceConfiguration.fetchFromIssuer(envConfig.LOGIN_BASE_URL, fetchRequestor);
        authorizationHandler = new RedirectRequestHandler(new LocalStorageBackend(window.sessionStorage), new NoHashQueryStringUtils(null, null, null), iFrameAuth.contentWindow.location);
        tokenHandler = new BaseTokenRequestHandler(fetchRequestor);
        const getToken = async (authorizationRequestResponse) => {
            const extras = { prompt: 'none' };
            extras['code_verifier'] = authorizationRequestResponse.request.internal['code_verifier'];
            const requestToken = new TokenRequest({
                client_id: envConfig.CLIENT_ID,
                redirect_uri: envConfig.LOGIN_REDIRECT_URL,
                grant_type: GRANT_TYPE_AUTHORIZATION_CODE,
                code: authorizationRequestResponse.response.code,
                refresh_token: undefined,
                extras
            });
            try {
                const tokenResponse = await tokenHandler.performTokenRequest(authorizationServiceConfiguration, requestToken);
                Logger.debugLogRequest('silent_auth', 'Token request completed successfully', env);
                return tokenResponse;
            }
            catch (e) {
                Logger.errorLogRequest('silent_auth', `Token request failed: ${JSON.stringify(e.message)}`, env);
                errorHandler();
            }
        };
        const request = new AuthorizationRequest({
            client_id: envConfig.CLIENT_ID,
            redirect_uri: envConfig.LOGIN_REDIRECT_URL,
            scope: 'openid',
            response_type: AuthorizationRequest.RESPONSE_TYPE_CODE,
            state: undefined,
            extras: { prompt: 'none' }
        });
        const recieveMessage = async (event) => {
            Logger.debugLogRequest('silent_auth', 'Received message event', env);
            if (envConfig.LOGIN_REDIRECT_URL.indexOf(event.origin) > -1) {
                if (event.data.state && event.data.code) {
                    authorizationHandler.locationLike = window.location; // Set locationlike to avoid cors problems
                    authorizationHandler.utils = new NoHashQueryStringUtils(event.data.code, event.data.state, null);
                    try {
                        const authorizationRequestResponse = await authorizationHandler.completeAuthorizationRequest();
                        Logger.debugLogRequest('silent_auth', 'Authorization Request Response received. Trying to get token...', env);
                        const tokenResponse = await getToken(authorizationRequestResponse);
                        Logger.debugLogRequest('silent_auth', 'Token response received. Handling token...', env);
                        if (tokenResponse) {
                            tokenReceivedHandler(tokenResponse);
                        }
                    }
                    catch (e) {
                        Logger.errorLogRequest('silent_auth', `Something really bad happened: ${JSON.stringify(e.message)}`, env);
                        errorHandler();
                    }
                }
                else if (event.data.state && event.data.error) {
                    Logger.errorLogRequest('silent_auth', `Received error from message, ${event.data.error}`, env);
                    errorHandler();
                }
            }
        };
        window.addEventListener('message', recieveMessage, { passive: true });
        authorizationHandler.performAuthorizationRequest(authorizationServiceConfiguration, request);
    }
    catch (error) {
        Logger.errorLogRequest('silent_auth', `Something bad happened: ${error.message}`, env);
        errorHandler();
    }
};
export const emitAccessToken = (element, env) => {
    const tokenReceivedHandler = (data) => {
        const accessTokenFetchedEvent = new CustomEvent(ACCESS_TOKEN_FETCHED_EVENT, { detail: data });
        element.dispatchEvent(accessTokenFetchedEvent);
    };
    const errorHandler = () => {
        const accessTokenFetchErrorEvent = new CustomEvent(ACCESS_TOKEN_FETCH_ERROR_EVENT);
        element.dispatchEvent(accessTokenFetchErrorEvent);
    };
    return () => fetchAccessToken(tokenReceivedHandler, errorHandler, env);
};
