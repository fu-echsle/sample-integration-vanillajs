export class HoverIntentService {
    constructor() {
        this.last = null;
    }
    async handleHoverOut() {
        clearTimeout(this.timeout);
        if (this.last) {
            await this.last.hideOverlay();
            this.link = null;
        }
    }
    closestElement(selector, base = this) {
        function closestFrom(el) {
            if (!el || el === document || el === window)
                return null;
            const found = el.closest(selector);
            return found ? found : closestFrom(el.getRootNode().host);
        }
        return closestFrom(base);
    }
    async handleMouseMove(event, parentElementSelector) {
        const element = event.composedPath().length === 0 ? this.capturedComposedPath[0] : event.composedPath()[0];
        const linkNominee = this.closestElement(parentElementSelector, element);
        this.mouseCursorX = event.clientX;
        this.mouseCursorY = event.clientY;
        if (!linkNominee) {
            const targetNode = event.target;
            if (this.link && !this.link.contains(targetNode)) {
                this.link = null;
            }
            return;
        }
        // conditionally set triangle’s top point
        if (linkNominee === this.link) {
            clearTimeout(this.timeout);
            if (!this.isInsideTriangle()) {
                this.originPositionX = this.mouseCursorX;
                this.originPositionY = this.mouseCursorY;
            }
        }
        else if (linkNominee !== this.link) {
            // and if still inside another link’s triangle
            if (this.link) {
                if (this.isInsideTriangle()) {
                    clearTimeout(this.timeout);
                    // capture composedPath() before the handleMouseMove event happens, as it becomes empty before the next event happens
                    this.capturedComposedPath = event.composedPath();
                    this.timeout = setTimeout(async () => {
                        if (this.link) {
                            await this.link.hideOverlay();
                            this.link = linkNominee;
                            await linkNominee.showOverlay();
                            this.originPositionX = this.mouseCursorX;
                            this.originPositionY = this.mouseCursorY;
                        }
                        this.handleMouseMove(event, parentElementSelector);
                    }, 100);
                    return;
                }
                await this.link.hideOverlay();
            }
            // set link
            this.link = linkNominee;
            this.last = this.link;
            this.originPositionX = this.mouseCursorX;
            this.originPositionY = this.mouseCursorY;
            // set triangle’s left point
            this.contentAreaLeftX = 280;
            this.contentAreaLeftY = 280;
            // set triangle’s right point
            this.contentAreaRightX = 540 + window.innerWidth / 2;
            this.contentAreaRightY = 280;
            // set link state
            await this.link.showOverlay();
        }
    }
    isInsideTriangle() {
        const b0 = (this.contentAreaLeftX - this.originPositionX) * (this.contentAreaRightY - this.originPositionY) -
            (this.contentAreaRightX - this.originPositionX) * (this.contentAreaLeftY - this.originPositionY), b1 = ((this.contentAreaLeftX - this.mouseCursorX) * (this.contentAreaRightY - this.mouseCursorY) -
            (this.contentAreaRightX - this.mouseCursorX) * (this.contentAreaLeftY - this.mouseCursorY)) /
            b0, b2 = ((this.contentAreaRightX - this.mouseCursorX) * (this.originPositionY - this.mouseCursorY) -
            (this.originPositionX - this.mouseCursorX) * (this.contentAreaRightY - this.mouseCursorY)) /
            b0, b3 = ((this.originPositionX - this.mouseCursorX) * (this.contentAreaLeftY - this.mouseCursorY) -
            (this.contentAreaLeftX - this.mouseCursorX) * (this.originPositionY - this.mouseCursorY)) /
            b0;
        return b1 > 0 && b2 > 0 && b3 > 0;
    }
}
