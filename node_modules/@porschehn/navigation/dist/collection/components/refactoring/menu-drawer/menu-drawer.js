import { Component, Element, Host, h, Method, Listen } from '@stencil/core';
import { MenuDrawerAnimation } from '../../../services/menu-drawer-animation';
import { navContentStore } from '../../../services/nav-content-store';
import { FEATURE_KEYBOARD, FOCUSABLE_ELEMENTS_SELECTOR, MENU_PHRASE_ID, PHRASEID_FIELD_NAME, TEXT_FIELD_NAME } from '../../../services/constants';
import { navStateStore } from '../../../services/nav-state-store';
import { isFeatureEnabled } from '../../../env-config';
export class MenuDrawer {
    constructor() {
        this.menuDrawerAnimation = new MenuDrawerAnimation();
        this.clickBackground = (event) => {
            this.handleClose(event);
        };
        this.clickMenu = (event) => {
            event.stopPropagation();
        };
    }
    async showContent(element) {
        this.menuDrawerAnimation.slideInMenuDrawer(element);
    }
    async hideContent(element) {
        this.menuDrawerAnimation.slideOutMenuDrawer(element);
    }
    slotChange(event) {
        // For Animation - e.g.
        // const drawerContent = this.el.querySelector('.menu-drawer-content') as HTMLElement;
        // drawerContent.style.right = '-100%';
        this.eventTriggered = event.target;
    }
    keyDownListener(event) {
        if (isFeatureEnabled(FEATURE_KEYBOARD, navContentStore.get('env'))) {
            this.enterTriggered = event.key === 'Enter';
            if (!event.shiftKey && event.key === 'Tab') {
                const focusable = this.el.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR);
                if (event.target === focusable[focusable.length - 1]) {
                    event.preventDefault();
                    const backButton = this.el
                        .closest('phn-menu-drawer')
                        .querySelector('phn-back-button > p-button-pure');
                    if (backButton) {
                        backButton.focus();
                    }
                    else {
                        const closeButton = this.el.closest('phn-menu-drawer').querySelector('phn-close-button');
                        closeButton.focus();
                    }
                }
            }
        }
        else {
            this.enterTriggered = false;
        }
    }
    componentDidUpdate() {
        if (this.enterTriggered && this.eventTriggered) {
            const accessibilityMarker = navStateStore.get('accessibilityMarker');
            let focusElement = null;
            if (accessibilityMarker && accessibilityMarker !== '') {
                focusElement = this.eventTriggered.querySelector('' + accessibilityMarker);
                if (focusElement) {
                    focusElement.focus();
                }
            }
            if (!focusElement) {
                focusElement = this.eventTriggered.querySelector('phn-back-button > p-button-pure');
                if (focusElement) {
                    focusElement.focus();
                }
                else {
                    focusElement = this.eventTriggered.querySelector('phn-close-button');
                    focusElement.focus();
                }
            }
        }
        // For Animation - e.g.
        // this.showContent(this.el);
        this.eventTriggered = null;
        this.enterTriggered = false;
    }
    handleBack() {
        const parentDrawerContent = navStateStore.get('parentDrawerContent');
        navStateStore.set('activeDrawerContent', parentDrawerContent[0]);
        navStateStore.set('parentDrawerContent', parentDrawerContent.filter((_, index) => index > 0));
        navStateStore.set('backButtonText', null);
    }
    handleClose(event) {
        navStateStore.reset();
        const menuDrawer = event.target.closest('.drawer-trigger');
        menuDrawer.hideContent(menuDrawer);
    }
    keyDownHandler(event) {
        if (isFeatureEnabled(FEATURE_KEYBOARD, navContentStore.get('env'))) {
            if (event.key === 'Enter') {
                navStateStore.reset();
                const menuDrawer = event.target.closest('.drawer-trigger');
                menuDrawer.hideContent(menuDrawer);
            }
        }
    }
    getValueForField(fieldName) {
        let text = '';
        const menu = navContentStore.get('menu');
        if (menu && menu.length > 0) {
            const menuItem = menu.find((m) => m.PhraseId === MENU_PHRASE_ID);
            if (menuItem && menuItem[fieldName]) {
                text = menuItem[fieldName];
            }
        }
        return text;
    }
    render() {
        const backButtonText = navStateStore.get('backButtonText') || this.getValueForField(TEXT_FIELD_NAME);
        const backButtonId = this.getValueForField(PHRASEID_FIELD_NAME);
        const parentDrawerContent = navStateStore.get('parentDrawerContent');
        const hasParent = parentDrawerContent.length > 0;
        const backAndCloseClass = hasParent ? 'drawer-back-and-close' : 'drawer-back-and-close drawer-close';
        return (h(Host, { class: "drawer-trigger" },
            h("div", { class: "menu-drawer" },
                h("div", { class: 'menu-drawer-container', onClick: this.clickBackground },
                    h("div", { class: "menu-drawer-content", onClick: this.clickMenu },
                        h("div", { class: "menu-drawer-content-wrapper" },
                            h("div", { class: backAndCloseClass },
                                hasParent && (h("phn-back-button", { class: "back-button", onClick: this.handleBack, buttonId: backButtonId, text: backButtonText })),
                                h("phn-close-button", { class: "close-button", onClick: this.handleClose, onKeyDown: this.keyDownHandler })),
                            h("slot", { name: "content" })))))));
    }
    static get is() { return "phn-menu-drawer"; }
    static get encapsulation() { return "scoped"; }
    static get originalStyleUrls() { return {
        "$": ["menu-drawer.scss"]
    }; }
    static get styleUrls() { return {
        "$": ["menu-drawer.css"]
    }; }
    static get methods() { return {
        "showContent": {
            "complexType": {
                "signature": "(element: HTMLPhnMenuDrawerElement) => Promise<void>",
                "parameters": [{
                        "tags": [],
                        "text": ""
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    },
                    "HTMLPhnMenuDrawerElement": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "",
                "tags": []
            }
        },
        "hideContent": {
            "complexType": {
                "signature": "(element: HTMLPhnMenuDrawerElement) => Promise<void>",
                "parameters": [{
                        "tags": [],
                        "text": ""
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    },
                    "HTMLPhnMenuDrawerElement": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "",
                "tags": []
            }
        }
    }; }
    static get elementRef() { return "el"; }
    static get listeners() { return [{
            "name": "slotUpdated",
            "method": "slotChange",
            "target": undefined,
            "capture": false,
            "passive": false
        }, {
            "name": "keydown",
            "method": "keyDownListener",
            "target": undefined,
            "capture": false,
            "passive": false
        }]; }
}
