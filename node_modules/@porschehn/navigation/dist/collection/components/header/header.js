import { Component, Element, Event, Listen, Prop, State, Watch, h } from '@stencil/core';
import { navContentStore } from '../../state/nav-content-store';
import { analyticsSetupStore } from '../../state/analytics-setup-store';
import * as contentService from '../../services/content-service';
import * as userService from '../../services/user-service';
import * as silentAuthService from '../../services/silent-auth-service';
import { Locale } from '../../entities/locale';
import { GeneralLoadEvent } from '../../services/datalayer/general-load-event';
import { config } from '../../env-config';
import { DEFAULT_ENVIRONMENT, DEFAULT_LOCALE, LOADING_STATUS, LOGGED_OUT_USER_STATUS, REDACTED, VERSION } from '../../utility/constants';
import { navStateStore } from '../../state/nav-state-store';
export class Header {
    constructor() {
        this.localeObject = new Locale(DEFAULT_LOCALE);
        this.locale = DEFAULT_LOCALE;
        this.env = DEFAULT_ENVIRONMENT;
        this.skipToMainContent = (event) => {
            // NOTE: To remain focused on the clicked element
            event.stopPropagation();
            const mainElement = this.el.shadowRoot.querySelector('#main');
            mainElement.tabIndex = 0;
            mainElement.focus();
        };
        this.mainContentTab = () => {
            const mainElement = this.el.shadowRoot.querySelector('#main');
            mainElement.tabIndex = -1;
        };
        this.addFocus = () => {
            const skipContentElement = this.el.shadowRoot.querySelector('p-button.skip-content');
            skipContentElement.classList.add('focused');
            const crestElement = this.el.shadowRoot.querySelector('phn-crest');
            skipContentElement.style.left = `${crestElement.getBoundingClientRect().right + 4}px`;
        };
        this.removeFocus = () => {
            const skipContentElement = this.el.shadowRoot.querySelector('p-button.skip-content');
            skipContentElement.classList.remove('focused');
        };
    }
    localeWatchHandler(newLocale) {
        this.localeObject.setLocale(newLocale);
        analyticsSetupStore.set('locale', new Locale(newLocale));
    }
    newAccessTokenReceived(newAccessToken, _) {
        if (newAccessToken !== REDACTED && newAccessToken !== this.accessTokenState) {
            this.accessTokenState = newAccessToken;
        }
        this.el.setAttribute('access-token', REDACTED);
    }
    accessTokenStateUpdated(newToken, oldToken) {
        if (newToken) {
            if (newToken !== oldToken) {
                userService.updateLoggedInStatus(newToken, this.localeObject).then((statusUpdated) => {
                    if (!statusUpdated) {
                        this.accessTokenState = undefined;
                        this.accessTokenExpired.emit();
                    }
                    else {
                        userService.updateUnreadMessagesCount(newToken);
                    }
                });
            }
        }
        else {
            navContentStore.set('loggedInState', LOGGED_OUT_USER_STATUS);
        }
    }
    handleAccessTokenFetchedEvent(event) {
        if (event.detail.accessToken) {
            this.accessTokenState = event.detail.accessToken;
        }
        else {
            navContentStore.set('loggedInState', LOGGED_OUT_USER_STATUS);
        }
    }
    handleAccessTokenFetchErrorEvent() {
        navContentStore.set('loggedInState', LOGGED_OUT_USER_STATUS);
    }
    async componentWillLoad() {
        analyticsSetupStore.set('window', window);
        analyticsSetupStore.set('environment', this.env);
        navContentStore.set('env', this.env);
        navStateStore.set('imagesLoaded', false);
        this.localeWatchHandler(this.locale);
        this.content = await contentService.fetchContent(this.env);
        const contentForLocale = contentService.getContentForLocale(this.localeObject, this.content, this.env);
        const myPorscheExists = contentForLocale.metafunctionalities && contentForLocale.metafunctionalities[1];
        if (this.accessToken) {
            if (this.accessToken !== REDACTED) {
                this.accessTokenState = this.accessToken;
                this.el.setAttribute('access-token', REDACTED);
            }
        }
        else if (config(this.env).PORSCHE_COM_URL.includes(window.location.origin) && myPorscheExists) {
            navContentStore.set('loggedInState', LOADING_STATUS);
            await silentAuthService.emitAccessToken(this.el, this.env)();
        }
        else {
            navContentStore.set('loggedInState', LOGGED_OUT_USER_STATUS);
        }
        navContentStore.set('seriesList', contentForLocale.seriesList);
        navContentStore.set('shops', contentForLocale.shops);
        navContentStore.set('more', contentForLocale.more);
        navContentStore.set('metafunctionalities', contentForLocale.metafunctionalities);
        navContentStore.set('menu', contentForLocale.menu);
    }
    async componentDidLoad() {
        const analyticsSetup = {
            applicationId: analyticsSetupStore.get('applicationId'),
            locale: analyticsSetupStore.get('locale'),
            window: analyticsSetupStore.get('window'),
            environment: analyticsSetupStore.get('environment')
        };
        const generalLoadEvent = new GeneralLoadEvent(analyticsSetup);
        const pagData = (window['pagData'] = window['pagData'] || []);
        pagData.push(generalLoadEvent.event());
        this.navigationDidLoad.emit();
    }
    componentWillUpdate() {
        const contentForLocale = contentService.getContentForLocale(this.localeObject, this.content, this.env);
        navContentStore.set('seriesList', contentForLocale.seriesList);
        navContentStore.set('shops', contentForLocale.shops);
        navContentStore.set('more', contentForLocale.more);
        navContentStore.set('metafunctionalities', contentForLocale.metafunctionalities);
        navContentStore.set('menu', contentForLocale.menu);
    }
    render() {
        return (h("header", { class: "header-container" },
            h("p-button", { variant: "primary", class: "skip-content", onfocus: this.addFocus, onClick: this.skipToMainContent, onblur: this.removeFocus }, "Skip to main content"),
            h("div", { class: "header limit-stretch" },
                h("div", { class: "crest-burger-btn-container" },
                    h("phn-crest", { class: "crest" }),
                    h("phn-mobile-layout", null)),
                h("nav", { class: "menu-container" },
                    h("phn-menu-desktop-level-1", { class: "menu-desktop-level-1" }))),
            h("div", { class: "header-border" }),
            this.env === 'preview' && h("phn-preview-badge", { versionString: `Header ${VERSION} - PP content` }),
            h("div", { id: "main", tabindex: "-1", class: "main-content", onBlur: this.mainContentTab })));
    }
    static get is() { return "phn-header"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() { return {
        "$": ["header.scss"]
    }; }
    static get styleUrls() { return {
        "$": ["header.css"]
    }; }
    static get assetsDirs() { return ["auth"]; }
    static get properties() { return {
        "accessToken": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "access-token",
            "reflect": false
        },
        "locale": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "locale",
            "reflect": false,
            "defaultValue": "DEFAULT_LOCALE"
        },
        "env": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "env",
            "reflect": false,
            "defaultValue": "DEFAULT_ENVIRONMENT"
        }
    }; }
    static get states() { return {
        "accessTokenState": {}
    }; }
    static get events() { return [{
            "method": "accessTokenExpired",
            "name": "accessTokenExpired",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": ""
            },
            "complexType": {
                "original": "any",
                "resolved": "any",
                "references": {}
            }
        }, {
            "method": "navigationDidLoad",
            "name": "navigationDidLoad",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": ""
            },
            "complexType": {
                "original": "any",
                "resolved": "any",
                "references": {}
            }
        }]; }
    static get elementRef() { return "el"; }
    static get watchers() { return [{
            "propName": "locale",
            "methodName": "localeWatchHandler"
        }, {
            "propName": "accessToken",
            "methodName": "newAccessTokenReceived"
        }, {
            "propName": "accessTokenState",
            "methodName": "accessTokenStateUpdated"
        }]; }
    static get listeners() { return [{
            "name": "accessTokenFetched",
            "method": "handleAccessTokenFetchedEvent",
            "target": undefined,
            "capture": false,
            "passive": false
        }, {
            "name": "accessTokenFetchError",
            "method": "handleAccessTokenFetchErrorEvent",
            "target": undefined,
            "capture": false,
            "passive": false
        }]; }
}
